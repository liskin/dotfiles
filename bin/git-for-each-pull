#!/usr/bin/env bash

set -eu -o pipefail
shopt -s lastpipe

# shellcheck source-path=..
. "$HOME"/bin/.o
# shellcheck source-path=..
. "$HOME"/bin/.oc

function ask-continue { return $?; }

options=$(unset GETOPT_COMPATIBLE && getopt -o "hni" --long dry-run,interactive,set-head,help -- "$@")
eval "set -- $options"

dry_run=
set_head=
while (( $# )); do
	opt=$1; shift
	case "$opt" in
		-h|--help)
			echo "Usage: $0 [-n|--dry-run] [-h|--help] [--set-head]"
			exit
			;;

		-n|--dry-run) dry_run=: ;;
		-i|--interactive) function ask-continue { ooc "error; continue?"; } ;;
		--set-head) set_head=: ;;
		--) break ;;
	esac
done
if (( $# )); then
	echo "No args expected"
	exit 1
fi

msgs=()

find -L . -maxdepth 2 -name .git | sort \
| while read -r repo; do
	repo=$(realpath --relative-base=. "${repo%/.git}")
	if [[ $set_head ]]; then
		o git -C "$repo" remote set-head --auto origin || ask-continue
	fi
	head=$(git -C "$repo" symbolic-ref -q refs/remotes/origin/HEAD) || {
		msgs+=("$repo - origin/HEAD unknown")
		continue
	}
	branch=$(git -C "$repo" current-branch) || {
		msgs+=("$repo - no current branch")
		continue
	}
	status=$(git -C "$repo" status --porcelain --untracked-files=no)
	if [[ $branch != "${head##*/}" ]]; then
		msgs+=("$repo - different branch: $branch != ${head##*/}")
	elif [[ $status ]]; then
		msgs+=("$repo - dirty")
	else
		if [[ ! $dry_run ]]; then
			o git -C "$repo" pull || ask-continue
		fi
	fi
done

for msg in "${msgs[@]}"; do
	oo "$msg"
done
